---
title: "Larsson2019"
author: 
  - name: Wancen Mu, Hirak Sarkar, Avi Srivastava, Kwangbom Choi, Rob Patro, Michael I. Love
date: "January 13, 2021"
abstract: |
  airpart is an R package that identifies subsets of genes displaying differential CTS allelic imbalance across all cell types.

  It consists of two paragraphs.
tags: [fusedlasso, Single cell]
output: 
  html_document:
    toc: true  
    toc_float: true 
    theme: united  
    highlight: tango  
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load data

First, we load the preprocessed [Larsson 2019](https://www.nature.com/articles/s41586-018-0836-1) data. It includes one allelic counts(`c57_fil`) and total counts(`total_fil`) which was derived after QC step. `cell_meta_unique` is a character vector of unique cell types names. `celltype` is a character vector of all cell types.

```{r}
suppressPackageStartupMessages(library(SingleCellExperiment))
load("../data/larsson.rda")
assay.list<-list(ase.mat=c57,ase.pat=cast)
coldata<-data.frame(x=factor(celltype$x,levels=c("mESC","G1","S","G2M")))
sce<-SingleCellExperiment(assays=assay.list, colData=coldata)
```

# Create Ratio matrix

Here we add the pseudo count for gene clustering and visualization.
```{r}
sce <- preprocess(sce)
```

# Estimate overdispersion parameter

```{r}
estDisp(sce)
```

Take a look at highest expressed genes
```{r}
counts(sce)[order(rowSums(counts(sce)),decreasing = T)[1:10],sample(dim(sce)[2],5)]
```
# Quality control step
## QC on cells
```{r}
cellQCmetrics<-cellQC(sce,mad_detected=4)
cellQCmetrics
```

Now define cell filtering automatically or users can manually filter out based on `sum`,`detected` and `spikePercent`. 
```{r}
remove_cell <- (
  cellQCmetrics$filter_sum | # sufficient features (genes)
  cellQCmetrics$filter_detected | # sufficient molecules counted
  cellQCmetrics$filter_spike  # sufficient features expressed compared to spike genes, high quality cells
) 
sce<-sce[,!remove_cell]
```

## QC on genes
Note that we require genes expressed in at least **25%** cells within each cell types. 
```{r, eval=FALSE}
featureQCmetric<-featureQC(sce)
keep_feature<-(featureQCmetric$filter_celltype &
                 featureQCmetric$filter_sd &
                 featureQCmetric$filter_spike)
sce<-sce[keep_feature,]
```
# Gene clustering

We provide two methods for gene clustering. 

## * Gaussian Mixture modeling

This is the default methods. The scatter plot is shown based on Top 2 PCs.
```{r}
sce<-geneCluster(sce, G=c(8,12,16,20,24,28))
metadata(sce)$geneCluster
```

## * Hierarchical clustering 
```{r,eval=FALSE}
sce.hc<-geneCluster(sce,method="hierarchical")
metadata(sce.hc)$geneCluster
```

# Running airpart

## Simple summary table of alleic ratio

Quickly look at the weighted mean of allelic ratio for each gene cluster. Identify the interested gene cluster. Note that we recommend users only run `airpart` when the largest ordered allelic ratio difference > 0.05 for speed concerns. We find that the allelic ratio of most of the gene clusters in such cases (small absolute allelic ratio differences) won't provide enough evidence to detect differential allelic imbalance.
```{r}
sce<-summaryAllelicRatio(sce)
summary<-metadata(sce)$summary
for(i in 1:length(summary)) {
  inst<-summary[[i]]
  inst_order <- inst[order(inst$weighted.mean),]
  idx[i]<-(max(diff(inst_order$weighted.mean)) > 0.05)
}
metadata(sce)$summary[idx]
```
Here we use gene cluster 17 as an example

## Modeling using fused lasso with quasibinomial likelihood

```{r}
f <- ratio ~ p(x, pen = "gflasso") # formula for the GFL
t<-system.time(sce_sub <- fusedLasso(formula=f,model="binomial",sce,genecluster = 4,ncores=4,niter=1))
knitr::kable(metadata(sce_sub)$partition,row.names = F)
```
Here `ncores` is the number of CPU used for parallelization. And it takes `r t`s with 4 CPU to test 55*367=20185 elements. Note, the computation time increases approximate linearly as number of genes increases. If you run `niter>1`, please use a `consensusPart` to derive the final partition.

## Modeling using pairwise Mann Whitney Wilcoxon extension

```{r,results='asis',warning=FALSE}
t<-system.time(sce_sub <- wilcoxExt(sce, genecluster=4, threshold =10^seq(from=-2,to=-0.4,by=0.1)))
knitr::kable(metadata(sce_sub)$partition,row.names = F)
```

It takes `r t2`s to run Wilcoxon.

## Calculating allelic Ratio estimator by betabinomial 
### Confidence interval with normal approximation
```{r,warning=FALSE, results="asis"}
sce_sub<-allelicRatio(sce_sub)
knitr::kable(metadata(sce_sub)$estimator,row.names = F)
```
```{r}
makeForest(sce_sub)
makeBoxplot(sce_sub)
makeRatioHeatmap(sce_sub)
```

## Graph-Guided Fused Lasso
Use the Graph-Guided Fused Lasso penalty to only regularize the differences of coefficients of neighboring areas. When using a Graph-Guided Fused Lasso penalty, the adjacency matrix corresponding to the graph needs to be provided. The elements of this matrix are zero when two levels are not connected (areas that do not share a border in our example), and one when they are adjacent (i.e. connected).
```{r}
adj <- matrix(0, nct, nct)
colnames(adj) <- rownames(adj) <- cell_meta_unique
adj[2,3]<-1
adj[3,c(2,4)]<-1
adj[4,3]<-1
f2 <- ratio ~ p(x, pen = "ggflasso")
fit3<-fusedlasso(formula=f2,data=dat,ncores=4,lambda=0.04,adj.matrix=list(x=adj))
co2 <- coef_reest(fit3)
co2 <- co2 + c(0,rep(co2[1],nct-1))
co2<-1/(1+exp(-co2))
print(co2)
```

# Session Info
```{r}
sessionInfo()
```


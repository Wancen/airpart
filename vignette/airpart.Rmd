---
title: "Differential cell-type-specific allelic imbalance with airpart"
author: 
  - name: Wancen Mu, Hirak Sarkar, Avi Srivastava, Kwangbom Choi, Rob Patro, Michael I. Love
date: "Feb 1, 2021"
abstract: |
  airpart is an R package that identifies subsets of genes 
  displaying differential allelic imbalance across cell types.
output: 
  html_document:
    toc: true
    toc_float: true 
    theme: united
    highlight: tango
vignette: |
  %\VignetteIndexEntry{Differential cell-type-specific allelic imbalance with airpart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

# Download package

```{r}
library(devtools)
load_all()
# library(airpart)
```

# Overview of data

We will simulate some data using `makeSimulatedData` function provided
within the *airpart* package.

### Simulation set-up

The default simulated example dataset has 3 gene clusters: one with
differential allelic imbalance (DAI) with larger allelic ratio (AR)
difference, one with balanced allelic expression, and the third one
wsith DAI with smaller AR difference than the first cluster. Below we
specify:

* the "noisy" cell count is 3
* the normal cell count is 20
* 4 cell types
* 10 cells within each cell types
* 25 genes within each gene cluster
* overdispersion parameter in `rbetabinom` is 20

```{r}
obj <- makeSimulatedData(mu1=3,mu2=20,nct=4,n=10,ngenecl=25,theta=20)
ase.mat <- obj$ase.mat # maternal allelic expression matrix
ase.pat <- obj$ase.pat # paternal allelic expression matrix
x <- obj$x # cell types factors
true.ratio <- obj$true.ratio
nct <- nlevels(x)
head(ase.mat[,1:5])
```

# Create allelic ratio matrix

Here we add the pseudo count for gene clustering and visualization.

```{r, messages=FALSE}
library(pheatmap)
library(gplots)
total <- ase.mat+ase.pat
ratio <- ase.mat/total
ratio_pseudo <- (ase.mat+2)/(total+4)
anno_df <- data.frame(x=factor(x), row.names=colnames(total))
pheatmap(ratio_pseudo,
         color=colorRampPalette(c("blue","white","red"))(101),
         breaks=0:100/100,
         annotation_col=anno_df,
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames=FALSE, show_rownames=FALSE)
```

The true partition is given by these underlying ratios:

```{r}
pheatmap(true.ratio,
         color=bluered(101),
         breaks=0:100/100,
         annotation_col=data.frame(x=factor(1:4), row.names=1:4),
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames=FALSE, show_rownames=FALSE)
```

# Gene clustering

We provide two methods for gene clustering. 

* Gaussian Mixture modeling

This is the default method. The scatter plot is shown based on Top 2
PCs. And `plot=FALSE` can be used to avoid showing the plot. 

```{r}
cluster <- genecluster(ratio_pseudo,nct,G=c(1:8))
table(cluster)
```

* Hierarchical clustering 

```{r,eval=FALSE}
cluster <- genecluster(ratio_pseudo,nct,method="hierarchical")
table(cluster)
```

# Running airpart

## Construct data.frame of input values

```{r}
library(tidyverse)
i <- 1
feat <- which(cluster == i) # choose genes location
cl_ratio <- as.vector(unlist(ratio[feat,]))
cl_total <- as.vector(unlist(total[feat,]))
dat <- data.frame(ratio=cl_ratio,
              x=factor(rep(x,each=length(feat))),
              cts=cl_total)
summary <- dat %>%
  group_by(x) %>%
  summarise(weighted.mean=weighted.mean(ratio,cts,na.rm = T),
            mean=mean(ratio,na.rm = T),
            var=var(ratio,na.rm = T)) %>%
  as.data.frame()
```

```{r, results = "asis"}
knitr::kable(summary)
```

```{r}
summary <- summary[order(summary$weighted.mean),]
max(diff(summary$weighted.mean)) > 0.05
```

Note that we recommend users only run `airpart` when the largest
ordered allelic ratio difference > 0.05 for speed concerns.
We find that the allelic ratio of most of the gene clusters
in such cases (small absolute allelic ratio differences) won't provide
enough evidence to detect differential allelic imbalance.

## Modeling using fused lasso with binomial likelihood

```{r}
f <- ratio ~ p(x, pen = "gflasso") # formula for the GFL
print(paste(length(feat),"genes may exhibit allelic ratio imbalance"))
t <- system.time({
  cl <- fusedlasso(formula=f,model="binomial",data=dat,ncores=2,niter=2)
})[[3]]
```

```{r, results="asis"}
knitr::kable(cl,row.names = T) # rownames are cell types
```

Here `ncores` is the number of CPU used for parallelization. One can
specify `niter=5` when the `cts` weighted allelic ratio difference
is smaller than 0.1, in order to provide additional estimator
robustness.

### Consensus partition

If you run `niter=5`, please use a consensus partition to derive the
final partition.

TODO: this should probably be live code... it's short enough that it
doesn't need a wrapper

```{r,results='asis',collapse=TRUE}
suppressPackageStartupMessages({library(clue)})

consens_part <- cl_consensus(
  cl_ensemble(list=apply(cl,2,as.cl_hard_partition)),
  method = "SM"
)
class <- max.col(consens_part$.Data)
class <- match(class,unique(class))
cl <- data.frame(part=factor(class),row.names = levels(x))
print(knitr::kable(cl,row.names = T))
```

## Modeling using pairwise Mann Whitney Wilcoxon extension


```{r}
t <- system.time({
  cl <- wilcox_adj(dat, threshold =10^seq(from=-2,to=-0.4,by=0.1))
})[[3]]
print(knitr::kable(cl,row.names = T))
```
## Calculating allelic Ratio estimator by betabinomial 

```{r}
cl["x"]<-levels(x) 
dat2 <- dat %>% left_join(cl, by="x")
```


```{r,warning=FALSE}
estimator<-betabinom(dat2,"part")
```

### Allelic ratio estimator

```{r}
coef <- as.vector(do.call(rbind, estimator[seq(1,length(estimator), by = 3)]))
est0 <- data.frame(part=factor(seq_len(length(coef))), estimator=coef)
est <- merge(cl, est0, by="part", all=TRUE) # combine with partition label
```

### Allelic Ratio Confidence interval

```{r}
confint <- matrix(do.call(rbind, estimator[seq(2,length(estimator), by = 3)]),ncol=2) %>%
  as.data.frame() %>%
  setNames(names(estimator[[2]]))
ci <- round(confint[as.numeric(cl$part),],3)
```

```{r, results="asis"}
ar<-cbind(est,ci)
print(knitr::kable(ar,row.names = F))
```
# Displaying results on heatmap

To demonstrate showing partition results on a heatmap, let's make a more
complex simulation:

TODO: looking at the code in one chunk helps to see that the code
could be simplified for the user, and it may makes sense to have an
object (a simple list is fine) that stores the parts for the
user. Let's discuss later. The basic steps are:

* make total, ratio, ratio_pseudo matrix
* genecluster [check]
* make data frame 
* add partition information to cell level information to make plots

```{r}
obj <- makeSimulatedData(mu1=3,mu2=20,nct=10,n=10,ngenecl=25,theta=20)
ase.mat <- obj$ase.mat # maternal allelic expression matrix
ase.pat <- obj$ase.pat # paternal allelic expression matrix
x <- obj$x # cell types factors
nct <- nlevels(x)
total <- ase.mat+ase.pat
ratio <- ase.mat/total
ratio_pseudo <- (ase.mat+2)/(total+4)
cluster <- genecluster(ratio_pseudo,nct,G=c(1:8))
i <- 1
feat <- which(cluster == i) # choose genes location
cl_ratio <- as.vector(unlist(ratio[feat,]))
cl_total <- as.vector(unlist(total[feat,]))
dat <- data.frame(ratio=cl_ratio,
                  x=factor(rep(x,each=length(feat))),
                  cts=cl_total)
f <- ratio ~ p(x, pen = "gflasso") # formula for the GFL
cl <- fusedlasso(formula=f,model="binomial",data=dat,ncores=2,niter=1)
anno_df <- data.frame(x=factor(x),
                      row.names=colnames(total))
cl["x"]<-levels(x) 
anno_df$part <- factor(cl$part[match(anno_df$x, cl$x)])
dat2 <- dat %>% left_join(cl, by="x")
estimator<-betabinom(dat2,"part")
coef <- as.vector(do.call(rbind, estimator[seq(1,length(estimator), by = 3)]))
est0 <- data.frame(part=factor(seq_len(length(coef))), estimator=round(coef,3))
est <- merge(cl, est0, by="part", all=TRUE) # combine with partition label
confint <- matrix(do.call(rbind, estimator[seq(2,length(estimator), by = 3)]),ncol=2) %>%
  as.data.frame() %>%
  setNames(names(estimator[[2]]))
ci <- round(confint[as.numeric(cl$part),],3)
ar<-cbind(est,ci)

library(forestplot)
forest_text<-rbind(colnames(ar),ar)
forest_plot<-data.frame(mean=c(NA,est$estimator),lower=c(NA,ci[,1]),upper=c(NA,ci[,2]))
xticks <- seq(from = 0, to = 1, by = 0.05)
xtlab <- rep(c(TRUE, FALSE), length.out = length(xticks))
attr(xticks, "labels") <- xtlab
forestplot(forest_text, 
           forest_plot,new_page = TRUE, boxsize = 0.15,
           hrzl_lines = list("2" = gpar(lty = 2)), lwd.ci = 2,
           clip = c(0,1.1),xticks = xticks, grid = structure(c(0.1, 0.5, 0.9), 
                            gp = gpar(lty = 2, col = "#CCCCFF")), 
           col = fpColors(box = "royalblue"),xlab = "Allelic Ratio")
```

# Heatmap
```{r}
library(ComplexHeatmap)
m<-ratio_pseudo[feat,]
rg = range(ratio_pseudo[feat,])
panel_fun = function(index, nm) {
    pushViewport(viewport(xscale = rg, yscale = c(0, 1)))
    grid.rect()
    grid.xaxis(gp = gpar(fontsize = 8))
    grid.boxplot(m[,index], pos = 1,direction = "horizontal")
    popViewport()
}
subgroup = anno_df$part
anno = anno_link(align_to = subgroup, which = "column", panel_fun = panel_fun, 
    size = unit(2, "cm"), gap = unit(1, "cm"), width = unit(4, "cm"))
ha = HeatmapAnnotation(foo=anno,
                      empty = anno_empty(border = FALSE, height = unit(8, "mm")),
                       part = anno_block(gp = gpar(fill = 2:11), 
                                         labels =paste0("ct",seq_len(10)),labels_gp = gpar(col = "white", fontsize = 10)))
split = anno_df$x
Heatmap(m, name = "Allelic Ratio", column_split = split, top_annotation = ha, 
    column_title = NULL,cluster_columns = F,cluster_rows = F,show_column_names = F)

library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), label = NULL, labels_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = labels_gp)
    }
}

group_block_anno(1:2, "empty", gp = gpar(fill = 1), label = "group 1",labels_gp = gpar(col = "white", fontsize = 12))
group_block_anno(3:4, "empty", gp = gpar(fill = 2), label = "group 2",labels_gp = gpar(col = "white", fontsize = 10))
group_block_anno(5:6, "empty", gp = gpar(fill = 3), label = "group 3",labels_gp = gpar(col = "white", fontsize = 10))
group_block_anno(7:8, "empty", gp = gpar(fill = 4), label = "group 4",labels_gp = gpar(col = "white", fontsize = 10))
group_block_anno(9:10, "empty", gp = gpar(fill = 5), label = "group 5",labels_gp = gpar(col = "white", fontsize = 10))

```

```{r}
dat2$x <- factor(dat2$x, 1:10)
with(dat2, boxplot(ratio ~ x, col=factor(cl$part)))
```

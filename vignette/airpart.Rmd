---
title: "Differential cell-type-specific allelic imbalance with airpart"
author: 
  - name: Wancen Mu, Hirak Sarkar, Avi Srivastava, Kwangbom Choi, Rob Patro, Michael I. Love
date: "Feb 1, 2021"
abstract: |
  airpart is an R package that identifies subsets of genes displaying differential CTS allelic imbalance across all cell types.
output: 
  html_document:
    toc: true
    toc_float: true 
    theme: united
    highlight: tango
vignette: |
  %\VignetteIndexEntry{Differential cell-type-specific allelic imbalance with airpart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Download package

TODO...

```{r}
library(airpart)
```

Recommend to call `library` at the position when you need the package,
instead of at the top, so users know which package is needed for which
chunk of code. Also you can use `suppressPackageStartupMessages`.

# Overview of data
We will simulate some data using `makeSimulateData` function provided within the `airpart` package

### Simulation set-up:
Default is 3 gene clusters, one has differential allelic imbalance(DAI) with larger allelic ratio(AR) difference, one is bi-allelic expression and the third one has DAI with smaller AR difference.

* noise cells count is 3
* normal cells count is 20
* 4 cell types
* 10 cells within each cell types
* 25 genes within each gene cluster
* overdispersion parameter in `rbetabinom` is 20

```{r}
obj <- makeSimulatedData(mu1=3,mu2=20,nct=4,n=10,ngenecl=25,theta=20)
```

```{r}
ase.mat <- obj$ase.mat # maternal allelic expression matrix
ase.pat <- obj$ase.pat # paternal allelic expression matrix
x <- obj$x # cell types factors
p.mat <- obj$p.mat
nct <- nlevels(x)
head(ase.mat[,1:5])
```

# Create Ratio matrix
Here we add the pseudo count for gene clustering and visualization.

```{r}
suppressPackageStartupMessages({library(gplots)})
suppressPackageStartupMessages({library(pheatmap)})
total <- ase.mat+ase.pat
ratio <- ase.mat/total
ratio_pseudo <- (ase.mat+2)/(total+4)
anno_df <- data.frame(x=factor(x), row.names=colnames(total))
pheatmap(ratio_pseudo,
         color=bluered(101),
         breaks=0:100/100,
         annotation_col=anno_df,
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames=F, show_rownames=F)
```

The true partition is given by these underlying ratios:

```{r}
pheatmap(p.mat,
         color=bluered(101),
         breaks=0:100/100,
         annotation_col=data.frame(x=factor(1:4), row.names=1:4),
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames=F, show_rownames=F)
```

# Gene clustering

We provide two methods for gene clustering. 

* Gaussian Mixture modeling

This is the default methods. The scatter plot is shown based on Top 2 PCs. And `plot=FALSE` to avoid showing the plot.
```{r}
cluster <- genecluster(ratio_pseudo,nct,G=c(1:8))
table(cluster)
```

* Hierarchical clustering 
```{r,eval=FALSE}
cluster <- genecluster(ratio_pseudo,nct,method="hierarchical")
table(cluster)
```
# Running airpart

## Construct dataframe
```{r}
library(tidyverse)
i=1
feat<-which(cluster==i) # choose genes location
cl_ratio<-as.vector(unlist(ratio[feat,]))
cl_total<-as.vector(unlist(total[feat,]))
dat<-tibble(ratio=cl_ratio,x=factor(rep(x,each=length(feat))),cts=cl_total)
summary<-dat %>% group_by(x) %>% summarise(weighted.mean=weighted.mean(ratio,cts,na.rm = T),mean=mean(ratio,na.rm = T),var=var(ratio,na.rm = T)) %>% data.frame()
print(knitr::kable(summary)) #check summary table
summary<-summary[order(summary$weighted.mean),]
max(diff(summary$weighted.mean))>0.05
```
Note that we recommend users only run `airpart` when the largest ordered allelic ratio difference>0.05 for speed up and accuracy. Because we find that the allelic ratio of most of the gene clusters here are consistent and won't detect any differential allelic imbalance.

## Modeling using fused lasso with binomial likelihood

```{r}
f <- ratio ~ p(x, pen = "gflasso")
print(paste(length(feat),"genes may exists allelic ratio imbalance"))
t<-system.time(cl_gfl<-fusedlasso(formula=f,model="binomial",data=dat,ncores=4,niter = 1))[[3]]
print(knitr::kable(cl_gfl))
```
Here `ncores` is the number of CPU used for parallelization.You can specify `niter=5` when the CTS weighted allelic ratio difference smaller than 0.1 and therefore there will have uncertainty.

## Consensus partation
```{r,results='asis',collapse=TRUE,eval=FALSE}
suppressPackageStartupMessages({library(clue)})
suppressPackageStartupMessages({library(fastmatch)})
consens_par<-cl_consensus(cl_ensemble(list = apply(cl,2,as.cl_hard_partition)),method = "SM")
class <- max.col(consens_par$.Data)
class <-fmatch(class,unique(class))

label<-tibble(type=levels(x),par=factor(class))
print(knitr::kable(label))
```
If you run `niter=5`, please use consensus partition to derive the final partition.

# Wilcoxon 
```{r}
t<-system.time(cl_wilcoxon<-wilcox_adj(dat,threshold =10^seq(from=-2,to=-0.4,by=0.1)))[[3]]
cl
```
```{r}
label<-tibble(type=levels(x),par_fused=as.vector(cl),par_wilcoxon=as.numeric(cl_wilcoxon))
label
dat2<-dat %>% left_join(label,by=c("x"="type"))
```


### Beta-binomial estimator for fused lasso
```{r,warning=FALSE}
estimator<-sapply (1:max(cl_gfl), function(m){
  bb<-vglm(cbind(ratio*cts, cts-ratio*cts) ~1, betabinomial, data = dat2[which(dat2$par_wilcoxon==m),], trace = F)
  coef_bb<-Coef(bb)[-2] # betabinomial estimator
  rho<-Coef(bb)[2]
  confint_bb<-confintvglm(bb,matrix=T)[-2,] # CI
  confint_wilcoxon<-1/(1+exp(-confint_bb)) 
  return(list(coef_bb,confint_wilcoxon,rho))
  })
  
  # allelic ratio estimator
  coef<-as.vector(do.call(rbind, estimator[seq(1,length(estimator), by = 3)]))
  est<-tibble(par_wilcoxon=factor(seq_len(length(coef))),estimator=coef)
  est2<-merge(label, est, by="par_wilcoxon", all = T) #combine with partation label
  print(knitr::kable(est2))
  
  # Normal approximation
  confint<-matrix(do.call(rbind, estimator[seq(2,length(estimator), by = 3)]),ncol=2) %>%as_tibble() %>% setNames(names(estimator[[2]]))
  normal<-round(confint[as.numeric(cl),],3)
  row.names(normal)<-label$type
  print(knitr::kable(normal))
```

```{r}
# Show result by graph
# g4 <- graph( c("G1", "S", "G1", "S", "G1", "S", "G1", "S","G1", "S","G1","S","S","G2/M"), 
# 
#              isolates=c("mESC"),directed = F )  
# 
# # In named graphs we can specify isolates by providing a list of their names.
# E(g4)
# E(g4)$type <- c(rep("model",5),rep("origin",2))
# V(g4)
# V(g4)$celltype <- c("fib","fib","fib","stem")
# plot(g4, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
#      vertex.color=c( "pink", "skyblue")[1+(V(g4)$celltype=="fib")],
#      edge.color=c("dark red", "slategrey")[(E(g4)$type=="origin")+1], ) 
```



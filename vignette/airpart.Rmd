---
title: "Differential cell-type-specific allelic imbalance with airpart"
author: 
  - name: Wancen Mu, Hirak Sarkar, Avi Srivastava, Kwangbom Choi, Rob Patro, Michael I. Love
date: "Feb 1, 2021"
abstract: |
  airpart is an R package that identifies subsets of genes 
  displaying differential allelic imbalance across cell types.
output: 
  html_document:
    toc: true
    toc_float: true 
    theme: united
    highlight: tango
vignette: |
  %\VignetteIndexEntry{Differential cell-type-specific allelic imbalance with airpart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

# Download package

```{r}
library(devtools)
load_all()
# library(airpart)
```

# Overview of data

We will simulate some data using `makeSimulatedData` function provided
within the *airpart* package.

### Simulation set-up

The default simulated example dataset has 3 gene clusters: one with
differential allelic imbalance (DAI) with larger allelic ratio (AR)
difference, one with balanced allelic expression, and the third one
wsith DAI with smaller AR difference than the first cluster. Below we
specify:

* the "noisy" cell count is 3
* the normal cell count is 20
* 4 cell types
* 10 cells within each cell types
* 25 genes within each gene cluster
* overdispersion parameter in `rbetabinom` is 20

```{r}
suppressPackageStartupMessages(library(SummarizedExperiment))
se <- makeSimulatedData(mu1=3,mu2=20,nct=4,n=10,ngenecl=25,theta=20)
```

```{r}
rowData(se)[c(1,26,51),]
table(colData(se))
assays(se)[["ase.mat"]][1:5,1:5]
```

# Create allelic ratio matrix

Here we add the pseudo count for gene clustering and visualization.

```{r}
se <- preprocess(se)
plotRatioHeatmap(se)
```

The true partition in the simulation is given by these underlying ratios:

```{r}
library(pheatmap)
anno_df <- data.frame(x=factor(1:4),row.names=paste0("ct",1:4))
pheatmap(rowData(se)[c(1,26,51),],
         color=colorRampPalette(c("blue","white","red"))(101),
         breaks=0:100/100,
         annotation_col=anno_df,
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames=FALSE, show_rownames=FALSE)
```

# Gene clustering

We provide two methods for gene clustering. 

* Gaussian Mixture modeling

This is the default method. The scatter plot is shown based on Top 2 PCs. And `plot=FALSE` can be used to avoid showing the plot. 


```{r}
se <- geneCluster(se, G=c(1:8))
table(rowData(se)$cluster)
```

* Hierarchical clustering 

```{r,eval=FALSE}
se <- geneCluster(se,method="hierarchical")
table(rowData(se)$cluster)
```

# Running airpart

## Simple summary table of alleic ratio

Quickly look at the weighted mean of allelic ratio for each gene cluster. Identify the interested gene cluster. 

```{r, results = "asis"}
summary<-summaryAllelicRatio(se)
summary
```

Note that we recommend users only run `airpart` when the largest ordered allelic ratio difference > 0.05 for speed concerns. We find that the allelic ratio of most of the gene clusters in such cases (small absolute allelic ratio differences) won't provide enough evidence to detect differential allelic imbalance.
```{r}
sapply(1:length(summary), function(i){
  inst<-summary[[i]]
  inst_order <- inst[order(inst$weighted.mean),]
  max(diff(inst_order$weighted.mean)) > 0.05
})
```

## Modeling using fused lasso with binomial likelihood

```{r}
f <- ratio ~ p(x, pen = "gflasso") # formula for the GFL
print(paste(length(feat),"genes may exhibit allelic ratio imbalance"))
se_sub <- fusedLasso(formula=f,model="binomial",se,genecluster = 1,ncores=2,niter=2)
```

```{r, results="asis"}
knitr::kable(unique(colData(se_sub)),row.names = F) # rownames are cell types
```

Here `ncores` is the number of CPU used for parallelization. One can
specify `niter=5` when the `cts` weighted allelic ratio difference
is smaller than 0.1, in order to provide additional estimator
robustness.

### Consensus partition

If you run `niter>1`, please use a consensus partition to derive the
final partition.

```{r,results='asis',collapse=TRUE}
se_sub<-consensusPart(se_sub)
knitr::kable(unique(colData(se_sub)),row.names = F)
```

## Modeling using pairwise Mann Whitney Wilcoxon extension


```{r}
se_sub <- wilcoxExt(se, genecluster=1, threshold =10^seq(from=-2,to=-0.4,by=0.1))
knitr::kable(unique(colData(se_sub)),row.names = F)
```

## Calculating allelic Ratio estimator by betabinomial 

```{r,warning=FALSE, results="asis"}
se_sub<-betaBinom(se_sub)
knitr::kable(unique(colData(se_sub)),row.names = F)
```

# Displaying results on heatmap

To demonstrate showing partition results on a heatmap, let's make a more
complex simulation:

The basic steps are:

* make total, ratio, ratio_pseudo matrix
* genecluster [check]
* make data frame 
* add partition information to cell level information to make plots

```{r}
se <- makeSimulatedData(mu1=3,mu2=20,nct=4,n=10,ngenecl=25,theta=20)
se <- preprocess(se)
se <- geneCluster(se, G=c(1:8))
summary<-summaryAllelicRatio(se) # identify interesting gene cluster

f <- ratio ~ p(x, pen = "gflasso") # formula for the GFL
se_sub <- fusedLasso(formula=f,model="binomial",se,genecluster = 1,ncores=2,niter=2) 
se_sub<-consensusPart(se_sub)
se_sub <- wilcoxExt(se, genecluster=1, threshold =10^seq(from=-2,to=-0.4,by=0.1)) # Alternative

se_sub<-betaBinom(se_sub)
makeForest(se_sub)
makeBoxplot(se_sub)
```


# Heatmap
```{r}
library(ComplexHeatmap)
m<-ratio_pseudo[feat,]
rg = range(ratio_pseudo[feat,])
panel_fun = function(index, nm) {
    pushViewport(viewport(xscale = rg, yscale = c(0, 1)))
    grid.rect()
    grid.xaxis(gp = gpar(fontsize = 8))
    grid.boxplot(m[,index], pos = 1,direction = "horizontal")
    popViewport()
}
subgroup = anno_df$part
anno = anno_link(align_to = subgroup, which = "column", panel_fun = panel_fun, 
    size = unit(2, "cm"), gap = unit(1, "cm"), width = unit(4, "cm"))
ha = HeatmapAnnotation(foo=anno,
                      empty = anno_empty(border = FALSE, height = unit(8, "mm")),
                       part = anno_block(gp = gpar(fill = 2:11), 
                                         labels =paste0("ct",seq_len(10)),labels_gp = gpar(col = "white", fontsize = 10)))
split = anno_df$x
Heatmap(m, name = "Allelic Ratio", column_split = split, top_annotation = ha, 
    column_title = NULL,cluster_columns = F,cluster_rows = F,show_column_names = F)

library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), label = NULL, labels_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = labels_gp)
    }
}

group_block_anno(1:2, "empty", gp = gpar(fill = 1), label = "group 1",labels_gp = gpar(col = "white", fontsize = 12))
group_block_anno(3:4, "empty", gp = gpar(fill = 2), label = "group 2",labels_gp = gpar(col = "white", fontsize = 10))
group_block_anno(5:6, "empty", gp = gpar(fill = 3), label = "group 3",labels_gp = gpar(col = "white", fontsize = 10))
group_block_anno(7:8, "empty", gp = gpar(fill = 4), label = "group 4",labels_gp = gpar(col = "white", fontsize = 10))
group_block_anno(9:10, "empty", gp = gpar(fill = 5), label = "group 5",labels_gp = gpar(col = "white", fontsize = 10))

```


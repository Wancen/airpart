---
title: "Differential cell-type-specific allelic imbalance with airpart"
author: 
  - name: Wancen Mu, Hirak Sarkar, Avi Srivastava, Kwangbom Choi, Rob Patro, Michael I. Love
date: "Feb 1, 2021"
abstract: |
  airpart is an R package that identifies subsets of genes displaying differential CTS allelic imbalance across all cell types.
output: 
  html_document:
    toc: true
    toc_float: true 
    theme: united
    highlight: tango
vignette: |
  %\VignetteIndexEntry{Differential cell-type-specific allelic imbalance with airpart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Download package

TODO...

```{r}
library(airpart)
```

Recommend to call `library` at the position when you need the package,
instead of at the top, so users know which package is needed for which
chunk of code. Also you can use `suppressPackageStartupMessages`.

# Overview of data
We will simulate some data using `makeSimulateData` function provided within the `airpart` package

### Simulation set-up:
Default is 3 gene clusters, one has differential allelic imbalance(DAI) with larger allelic ratio(AR) difference, one is bi-allelic expression and the third one has DAI with smaller AR difference.

* noise cells count is 3
* normal cells count is 20
* 4 cell types
* 10 cells within each cell types
* 25 genes within each gene cluster
* overdispersion parameter in `rbetabinom` is 20

```{r}
obj <- makeSimulatedData(mu1=3,mu2=20,nct=4,n=10,ngenecl=25,theta=20)
```

```{r}
ase.mat<-obj$ase.mat # maternal allelic expression matrix
ase.pat<-obj$ase.pat # paternal allelic expression matrix
x<-obj$x # cell types factors
nct<-max(as.numeric(x))
head(ase.mat[,1:5])
```

# Create Ratio matrix
Here we add the pseudo count for gene clustering and visualization.
```{r}
suppressPackageStartupMessages({library(gplots)})
suppressPackageStartupMessages({library(pheatmap)})
total<-ase.mat+ase.pat
ratio<-ase.mat/total
ratio_pseudo<-(ase.mat+2)/(total+4)
pheatmap(ratio_pseudo,color=bluered(95), cluster_rows = FALSE, cluster_cols = FALSE,show_colnames = F,show_rownames = F)
```

# Gene clustering

We provide two methods for gene clustering. 

* Gaussian Mixture modeling

This is the default methods. The scatter plot is shown based on Top 2 PCs. And `plot=FALSE` to avoid showing the plot.
```{r}
cluster<-genecluster(ratio_pseudo,nct,G=c(1:8))
table(cluster)
```

* Hierarchical clustering 
```{r,eval=FALSE}
cluster<-genecluster(ratio_pseudo,nct,method="hierarchical",plot = FALSE)
table(cluster)
```
# Running airpart

## Construct dataframe
```{r}
library(tidyverse)
i=1
feat<-which(cluster==i) # choose genes location
cl_ratio<-as.vector(unlist(ratio[feat,]))
cl_total<-as.vector(unlist(total[feat,]))
dat<-tibble(ratio=cl_ratio,x=factor(rep(x,each=length(feat))),cts=cl_total)
summary<-dat %>% group_by(x) %>% summarise(weighted.mean=weighted.mean(ratio,cts,na.rm = T),mean=mean(ratio,na.rm = T),var=var(ratio,na.rm = T)) %>% data.frame()
print(knitr::kable(summary)) #check summary table
summary<-summary[order(summary$weighted.mean),]
max(diff(summary$weighted.mean))>0.05
```
Note that we recommend users only run `airpart` when the largest ordered allelic ratio difference>0.05 for speed up and accuracy. Because we find that the allelic ratio of most of the gene clusters here are consistent and won't detect any differential allelic imbalance.

## Modeling using fused lasso with binomial likelihood

```{r}
f <- ratio ~ p(x, pen = "gflasso")
print(paste(length(feat),"genes may exists allelic ratio imbalance"))
t<-system.time(cl<-fusedlasso(formula=f,model="binomial",data=dat,ncores=4,niter = 1))[[3]]
print(knitr::kable(cl %>% data.frame()))
```
Here `ncores` is the number of CPU used for parallelization.You can specify `niter=5` when the CTS weighted allelic ratio difference smaller than 0.1 and therefore there will have uncertainty.

## Consensus partation
```{r,results='asis',collapse=TRUE,eval=FALSE}
suppressPackageStartupMessages({library(clue)})
suppressPackageStartupMessages({library(fastmatch)})
consens_par<-cl_consensus(cl_ensemble(list = apply(cl,2,as.cl_hard_partition)),method = "SM")
class <- max.col(consens_par$.Data)
class <-fmatch(class,unique(class))

label<-tibble(type=levels(x),par=factor(class))
print(knitr::kable(label))
```
If you run `niter=5`, please use consensus partition to derive the final partition.

# Wilcoxon 
```{r}
t<-system.time(cl<-wilcox_adj(dat,threshold =10^seq(from=-2,to=-0.4,by=0.1)))[[3]]
cl
```


```{r}
# Show result by graph
# g4 <- graph( c("G1", "S", "G1", "S", "G1", "S", "G1", "S","G1", "S","G1","S","S","G2/M"), 
# 
#              isolates=c("mESC"),directed = F )  
# 
# # In named graphs we can specify isolates by providing a list of their names.
# E(g4)
# E(g4)$type <- c(rep("model",5),rep("origin",2))
# V(g4)
# V(g4)$celltype <- c("fib","fib","fib","stem")
# plot(g4, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
#      vertex.color=c( "pink", "skyblue")[1+(V(g4)$celltype=="fib")],
#      edge.color=c("dark red", "slategrey")[(E(g4)$type=="origin")+1], ) 
```



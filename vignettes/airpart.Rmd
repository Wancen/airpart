---
title: "Differential cell-type-specific allelic imbalance with airpart"
author: 
  - name: Wancen Mu, Hirak Sarkar, Avi Srivastava, Kwangbom Choi, 
          Rob Patro, Michael I. Love
date: "Feb 1, 2021"
abstract: |
  Airpart identifies sets of genes displaying differential
  cell-type-specific allelic imbalance across cell types
  or states, utilizing single-cell allelic counts. It makes use of a
  generalized fused lasso with binomial observations of allelic
  counts to partition cell types by their allelic
  imbalance. Alternatively, a nonparametric method for partitioning
  cell types is offered. The package includes a number of
  visualizations and quality control functions for examining single
  cell allelic imbalance datasets.
output: 
  html_document:
    toc: true
    toc_float: true 
    theme: united
    highlight: tango
vignette: |
  %\VignetteIndexEntry{Differential allelic imbalance with airpart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

# Overview of input data

The airpart package takes input data of counts from each of two
alleles across genes (rows) and cells (columns) from a single-cell
RNA-seq experiment.

For demonstration in the package vignette, We will simulate some data
using `makeSimulatedData` function provided within the *airpart*
package. We will examine the allelic counts and then perform QC steps
before analyzing the data for allelic imbalance across groups of cells.

### Simulation set-up

The simulated example dataset has 3 gene clusters with differential
allelic imbalance (DAI): 

* the first cluster has pairs of cell types with same allelic ratio
  with 0.2 and 0.8 (larger DAI) 
* the second cluster has balanced allelic ratio
* the third cluster has pairs of cell types with same allelic ratio
  with 0.7 and 0.9 (smaller DAI)

Below we specify a number of simulation settings as arguments to the
simulation function:

* the "noisy" cell count is 2
* the normal cell count is 10
* 4 cell types
* 20 cells within each cell types
* 25 genes within each gene cluster
* overdispersion parameter `theta` in `rbetabinom` is 20 (higher is
  less dispersion)

```{r}
library(airpart)
suppressPackageStartupMessages(library(SingleCellExperiment))
p.vec <- rep(c(0.2,0.8,0.5,0.5,0.7,0.9),each=2)
set.seed(2021)
sce <- makeSimulatedData(mu1 = 2, mu2 = 10, nct = 4,n = 20,
                         ngenecl = 25, theta = 20, ncl = 3,
                         p.vec = p.vec)
```

```{r}
unique(rowData(sce)) # the true underlying allelic ratios
table(sce$x) # counts of each cell type
assays(sce)[["a1"]][1:5,1:5] # allelic counts for the effect allele
```

### Required input data

In summary, *airpart* expects a *SingleCellExperiment* object with:

* discrete cell types recorded as a variable `x` in the `colData(sce)`
* effect and non-effect allelic counts as assays `a1` and `a2`

The allelic ratio is calculated as `a1 / (a1 + a2)`.

```{r}
assayNames(sce)
sce$x
```

# Create allelic ratio matrix

In the `preprocess` step, we add a pseudo-count for gene clustering
and visualization (not used for inference later on allelic imbalance
though, which uses original allelic counts). From the heatmap, we can
clearly identify the three gene clusters (across rows), and we also
see cell type differences (across columns). Within each cell type,
there are some cells with noisier estimates (lower total count) than
others. Again, the allelic ratio tells us how much more of the `a1`
allele is expressed, with 1 indicating all of the expression coming
from the `a1` allele and 0 indicating all of the expression coming
from the `a2` allele.

```{r}
sce <- preprocess(sce)
makeRatioHeatmap(sce)
```

The true partition in the simulation is given by these underlying
ratios (this code only useful for simulated data, as true allelic
ratio would not be known from scRNA-seq data).

```{r}
library(pheatmap)
anno_df <- data.frame(x=factor(1:length(p.vec)),
                      row.names=paste0("ct",1:length(p.vec)))
pheatmap(unique(rowData(sce)),
         color=colorRampPalette(c("blue","white","red"))(101),
         breaks=0:100/100,
         annotation_col=anno_df,
         cluster_rows=FALSE, cluster_cols=FALSE,
         show_colnames=FALSE, show_rownames=FALSE)
```

# Quality control steps

## QC on cells

We recommend both QC on cells and on genes. We begin with cell allelic
ratio quality control. For details on these metrics, see `?cellQC`.

```{r}
cellQCmetrics <- cellQC(sce,mad_detected=4)
cellQCmetrics
```

Now define cell filtering automatically or users can manually filter
out based on `sum`,`detected` and `spikePercent`.

```{r}
keep_cell <- (
  cellQCmetrics$filter_sum | # sufficient features (genes)
  cellQCmetrics$filter_detected | # sufficient molecules counted
  # sufficient features expressed compared to spike genes, high quality cells
  cellQCmetrics$filter_spike  
) 
sce <- sce[,keep_cell]
```

## QC on genes

We also recommend QC on genes for allelic ratio analysis. Note that we
require genes to be expressed in at least **25%** of cells within each
cell type and the genes to have high allelic imbalance variation
across cell types. The following code chunk is recommended (not
evaluated here though). If users want to estimate homogeneous cell
type allelic imbalance, they can set `sd = 0` and examine the below
summary step to find interested gene clusters with weighted mean
deviating from 0.5.

```{r, eval=FALSE}
featureQCmetric <- featureQC(sce)
keep_feature <- (featureQCmetric$filter_celltype &
                 featureQCmetric$filter_sd &
                 featureQCmetric$filter_spike)
sce <- sce[keep_feature,]
```

# Gene clustering

*airpart* provides a function to cluster genes by their allelic
imbalance profile across cells. We then recommend providing genes
within a cluster to the partition function. Clustering genes increases
power for detecting cell type partitions, and improves speed as it
reduces the number of times the partition must be estimated.

We provide two methods for gene clustering. 

1. Gaussian Mixture modeling

Gaussian mixture modeling is the default method for gene
clustering. The scatter plot is shown based on top 2 PCs of the
smoothed allelic ratio data. The argument `plot=FALSE` can be used to
avoid showing the plot.

```{r}
sce <- geneCluster(sce, G=1:4)
metadata(sce)$geneCluster
```

2. Hierarchical clustering 

```{r}
sce.hc <- geneCluster(sce, method="hierarchical")
metadata(sce.hc)$geneCluster
```

In this simulated dataset case, the clustering is very similar, but on
allelic scRNA-seq datasets, we have found improved clustering with the
Gaussian mixture model approach (more similar genes within cluster,
based on visual inspection in PC space and of allelic ratio heatmaps).

# Running airpart for allelic imbalance across cells

## Simple summary table of alleic ratio

We first quickly look at the weighted mean of allelic ratio for each
gene cluster. From this step we will identify the interesting gene
clusters.

```{r}
sce <- summaryAllelicRatio(sce)
metadata(sce)$summary
```

The following step is a complement of the QC on genes step.  We
recommend users only run *airpart* when the largest ordered allelic
ratio difference > 0.05 for speed concerns. We find that the allelic
ratio of most of the gene clusters in such cases (small absolute
allelic ratio differences) won't provide enough evidence to detect
differential allelic imbalance.

```{r}
summary <- metadata(sce)$summary
sapply(1:length(summary), function(i){
  inst <- summary[[i]]
  inst_order <- inst[order(inst$weighted.mean),]
  max(diff(inst_order$weighted.mean)) > 0.05
})
```

## Experiment-wide beta-binomial over-dispersion

We recommend examining the experiment-wide beta-binomial
over-dispersion, which helps to inform whether to use a binomial
likelihood or a nonparametric approach to partitioning the cell types
by allelic imbalance.

```{r}
estDisp(sce)
```

## Modeling using fused lasso with binomial likelihood

*airpart* offers a method for partitioning cell types using the
generalized fused lasso with binomial likelihood, as implemented in
the *smurf* package. Cell types are merged based on their similarity
of allelic ratios, accounting for excess variability on the ratio from
low counts. The penalization is determined using deviance on held-out
data, with a 1 SE cross-validation rule for favoring smaller models
(more fused cell types).

```{r}
sce_sub <- fusedLasso(sce,model="binomial",
                      genecluster=1, ncores=2, niter=2)
```

The penalty $\lambda$ in fused lasso as well as partition groups are
stored in the metadata. 

```{r, results="asis"}
knitr::kable(metadata(sce_sub)$partition, row.names=FALSE)
```

```{r}
metadata(sce_sub)$lambda
```

Here `ncores` is the number of CPU used for parallelization. As a
guide, one can specify `niter=5` when the `cts` weighted allelic ratio
difference is smaller than 0.1, in order to provide additional
estimator robustness.

### Consensus partition

If you run `niter` > 1, you can use our consensus partition function
to derive the final partition. This function makes use of ensemble
consensus clustering via the *clue* package.

```{r, results='asis', collapse=TRUE}
sce_sub <- consensusPart(sce_sub)
knitr::kable(metadata(sce_sub)$partition, row.names=FALSE)
```

## Modeling using pairwise Mann Whitney Wilcoxon extension

An alternative to the fused lasso with binomial likelihood is an
extension we have implemented wherein all pairs cell types are
compared with Mann Whitney Wilcoxon rank sum tests. In practice, we
find that when the allelic counts deviates strongly from a binomial
(e.g. large over-dispersion), the `wilcoxExt` function can offer
improved performance, in terms of recovery of the true partition of
cell types by allelic imbalance. The partition is decided based on a
loss function motivated by the Bayesian Information Criteria 

TODO: is the last line correct?

```{r}
thrs <- 10^seq(from=-2,to=-0.4,by=0.2)
sce_sub <- wilcoxExt(sce, genecluster=1, threshold=thrs)
knitr::kable(metadata(sce_sub)$partition, row.names=FALSE)
metadata(sce_sub)$threshold
```

## Calculating allelic ratio estimate via beta-binomial

After *airpart* determines a partition of cell types either by the fused
lasso with binomial likelihood or the nonparametric approach described
above, it offers estimation of the allelic ratio per cell type (and
confidence intervals) via beta-binomial GLM, using functionality from
the *VGAM* package.

Note that the estimates and confidence intervals are not equal for
cell types in the same partition, because in this step we re-estimate
the conditional cell type means per original cell type.

The following confidence interval options are provided:

* Confidence interval with normal approximation.

```{r, warning=FALSE, fig.width=12}
sce_sub <- allelicRatio(sce_sub, trace=FALSE)
makeForest(sce_sub)
```

```{r results="asis"}
knitr::kable(metadata(sce_sub)$estimator, row.names=FALSE)
```

* Confidence interval with bootstrap percentiles.

```{r, warning=FALSE, results="asis"}
sce_sub <- allelicRatio(sce_sub, method="bootstrap", R=5, ncpus=2,
                        parallel="multicore",trace=FALSE)
knitr::kable(metadata(sce_sub)$estimator, row.names=FALSE)
```

# Displaying allelic partition results on a heatmap

To demonstrate showing partition results on a heatmap, let's make a
more complex simulation, with 8 cell types, in 3 true groups
by allelic ratio.

In the below code, we construct the more complex simulation, run
preprocessing, and examine the allelic ratio heatmap.

```{r}
nct <- 8
p.vec <- ( rep(c(
    -3,0,-3,3,
    rep(0,nct/2),
    2,3,4,2
  ), each=2) + 5 ) / 10
sce <- makeSimulatedData(mu1=2, mu2=10, nct=nct, n=30,
                         ngenecl=50, theta=20, ncl=3, p.vec=p.vec)
sce <- preprocess(sce)

cellQCmetrics <- cellQC(sce,mad_detected=4)
keep_cell <- (
  cellQCmetrics$filter_sum | # sufficient features (genes)
  cellQCmetrics$filter_detected | # sufficient molecules counted
  # sufficient features expressed compared to spike genes, high quality cells
  cellQCmetrics$filter_spike  
) 
sce <- sce[,keep_cell]

featureQCmetric <- featureQC(sce)
keep_feature <- (featureQCmetric$filter_celltype &
                 featureQCmetric$filter_sd &
                 featureQCmetric$filter_spike)
sce <- sce[keep_feature,]

makeRatioHeatmap(sce)
```

We can then perform gene clustering:

```{r}
sce <- geneCluster(sce, G=1:4)
```

We identify an interesting gene cluster, and then check for
experiment-wide beta-binomial over-dispersion (again, not that larger
`theta` (y-axis) corresponds to *less* over-dispersion.

```{r}
sce <- summaryAllelicRatio(sce)
estDisp(sce)
```

We then run the fused lasso and make the forest plot:

```{r fig.width=12}
sce_sub <- fusedLasso(sce, model="binomial",
                      genecluster=1, ncores=2) 
sce_sub <- allelicRatio(sce_sub, trace=FALSE)
makeForest(sce_sub)
```

A violin plot with allelic ratios on the y-axis:

```{r}
makeViolin(sce_sub)
```

Finally, a heatmap as before, but now with the cell types grouped
according to the partition:

```{r}
makeRatioHeatmap(sce_sub)
```

Or a heatmap can be shown by cell type ordered.

TODO: I want to also split heatmap in this case, but I don't know how
to detect change point on factors without importing another package. 
eg. I have c(1,1,2,2,1,1,3,3), how do I get c(1,1,2,2,3,3,4,4)?

```{r}
makeRatioHeatmap(sce_sub,order_by_group = FALSE)
```

# Per gene testing 

If users want to find differential allelic imbalance for a specific
gene, the following code can be used. It runs the fused lasso to
detect allelic imbalance partitions per gene.

```{r}
sce_gene <- sce_sub[c("gene1","gene2"),]
rowData(sce_gene)$cluster <- seq_len(nrow(sce_gene))
library(pbapply)
fl <- pbsapply(seq_len(nrow(sce_gene)), function(i) {
  sce_genesub <- fusedLasso(sce_gene, model="binomial",
                            genecluster = i, ncores=2)
  sce_genesub <- allelicRatio(sce_genesub, trace=FALSE)
  print(metadata(sce_genesub)$estimator)
}, cl=1)
```

# Session Info

```{r}
sessionInfo()
```
